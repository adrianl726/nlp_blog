{
  "hash": "22ba3ff8c2431583610e257c3400b35e",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"A Guide to Encoding Texts for Natural Language Processing\"\nauthor: \"Adrian Leung\"\ndate: \"2025-01-17\"\ncategories: [tutorial]\ntbl-cap-location: bottom\nembed-resources: true\nbibliography: references.bib\ncsl: diabetologia.csl\n---\n\n\n\n\n![Source: Google](nlp.png)\n\n## Introduction\n\nNatural Language Processing (NLP) is a fascinating field of Machine Learning that focuses on enabling machines to understand, interpret, and generate human language. From facilitating translation tools like Google Translate to powering voice assistance like Siri and Alexa, NLP's influence on the current technological landascape is indisputable and substantial. With the ever growing interest and expanding development in artificial intelligence, a lot of aspiring engineers and scientists are looking to venture into the lucrative NLP field. However, before we learn to perform all the fancy tasks such as text generations and summarizations, we must start from the fundamentals and ask ourselves a question:  \n\n**How can we bridge the gap between human communication and machine processing?**\n\nOne problem arises from this question is that computers do not understand language the way humans do. They are not wired to comprehend words and write essays like we do. Instead, they operate on numbers. All the NLP models are driven by mathematical algorithms and formulae. Thus, encoding text into numerical representations becomes the key to computers learning human language. By converting words, sentences, or entire documents into numbers, NLP models can perform a wide range of tasks like analyzing patterns, extracting meanings, and generating responses. \n\nThis blog will introduce and guide you through different methods and tools to encode texts, thus providing you a gateway to using NLP models.\n\n## Challenges of Textual Data\n\nBefore we learn about different ways to encode texts, we need to acknowledge the challenges associated with the intricacy of human language. Language is messy and unpredictable. Although there are sets of grammatical rules that govern a language, humans are prone to making mistakes yet still able to convey their messages. For example, \"How is you doin\" is grammatically incorrect but we know it means \"How are you doing\". Thus, language is not strictly restricted by an algorithm, contrary to how computers operate.\n\nMoreover, not all words have meanings. Auxiliary verbs like \"is\" and \"am\" do not contribute or change the message a sentence wants to convey. They are meaningless outside of abiding by grammatical rules. There is also a hierarchy of meanings in a sentence. Certain words can mean more than others. Consider the sentence \"We are happy\". Although \"we\" and \"happy\" play their roles in conveying our emotions, \"happy\" is a more important word as it tells the key emotion. \n\nTo complicate matters more, a word can have different meanings depending on the context. Even more confusingly, some words can have completely opposite meanings. For example, the word \"left\" in the sentence \"We just left\" means departed. However, it means staying when the sentence is \"We are the only one left\". This shows that contexts can alter meanings of the same word drastically.\n\n::: {style=\"text-align:center;\"}\n![Context matters!!! (Source: Kamala Harris)](context.gif)\n:::\n\nHence, making computers comprehend language like we do is far from a simple task. Encoding words with numerical representations is a work of art as it determines how well a model can understand us. \n\nThe sections below will cover different approaches to encoding texts including traditional methods like Bag-of-Words (BoW) and TF-IDF, word embeddings, and contextualized embeddings. \n\n## Traditional Methods\n\n### Bag-of-Words (BoW)\nBoW is one of the most popular encoding methods. It encodes each unique word from all input documents with a number based on their count or presence in their respective document.\n\nConsider the example below:\n\nUnique words in all documents:\n**['the', 'bird', 'is', 'cat', 'and', 'dog', 'hate', 'each', 'no', 'other']**\n\nAnd we pick one of the documents for our first BoW representation as below.  \n\nDocument: **\"The cat and the cat hate each other.\"**\n\nIn the case of encoding each word with its count, the BoW model will transform the document to the representation in @tbl-boWcount. Since we have two 'the' and 'cat' in the document above, the numerical representations for 'the' and 'cat' in this document are 2.\n\n|the|bird|is |cat|and|dog|hate|each|no |other|\n|:-:|:--:|:-:|:-:|:-:|:-:|:--:|:--:|:-:|:---:|\n| 2 | 0  | 0 | 2 | 1 | 0 | 1  |  1 | 0 |  1  |\n\n: BoW representations using word counts {#tbl-boWcount}\n\nAnd in the case of measuring each word by its presence as seen in @tbl-boWbinary, BoW uses binary values 0 and 1 to represent each word, where 0 implies absence and 1 implies presence. Note that the words 'the' and 'cat' are represented by 1 instead of 2 since we are using binary representations.\n\n|the|bird|is |cat|and|dog|hate|each|no |other|\n|:-:|:--:|:-:|:-:|:-:|:-:|:--:|:--:|:-:|:---:|\n| 1 | 0  | 0 | 1 | 1 | 0 | 1  |  1 | 0 |  1  |\n\n: BoW representations using binary indicators {#tbl-boWbinary}\n\nTo extract BoW representations in Python [@van1995python], we can leverage the `CountVectorizer` function from the `scikit-learn` package [@scikit-learn]. @tbl-sklearn demonstrates using `CountVectorizer` for BoW extraction by word count with the same example. \n\n::: {#tbl-sklearn .cell tbl-cap='BoW results from CountVectorizer' execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\nfrom sklearn.feature_extraction.text import CountVectorizer\n\n# Using above example\ndocuments = [\n    'The cat and the cat hate each other.',\n    'The dog is the bird.',\n    'No, the bird and cat hate other dog.'\n]\n\nbow = CountVectorizer()\nX = bow.fit_transform(documents)\nbow_df = pd.DataFrame(\n    X.toarray(), columns=bow.get_feature_names_out(), index=documents\n)\nbow_df\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>and</th>\n      <th>bird</th>\n      <th>cat</th>\n      <th>dog</th>\n      <th>each</th>\n      <th>hate</th>\n      <th>is</th>\n      <th>no</th>\n      <th>other</th>\n      <th>the</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>The cat and the cat hate each other.</th>\n      <td>1</td>\n      <td>0</td>\n      <td>2</td>\n      <td>0</td>\n      <td>1</td>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>1</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>The dog is the bird.</th>\n      <td>0</td>\n      <td>1</td>\n      <td>0</td>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>No, the bird and cat hate other dog.</th>\n      <td>1</td>\n      <td>1</td>\n      <td>1</td>\n      <td>1</td>\n      <td>0</td>\n      <td>1</td>\n      <td>0</td>\n      <td>1</td>\n      <td>1</td>\n      <td>1</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nAlthough the BoW method is as intuitive and self-explanatory as it seems, it is far from a perfect model as it discards the word order in the original document. It disregards how words can form meaningful word phrases and change their meanings with respect to the context.\n\n### TF-IDF\nTF-IDF, which stands for term frequency-inverse document frequency, is another popular method to encode text. It is a measure of relevance of a word in a document. The computation can be broken down into two parts: term frequency and inverse document frequency.\n\n**Term Frequency (TF)**  \nThe term frequency is the count of a given word $w$ in a given document $d$, divided by the total number of words in document $d$. \n\n$$TF = \\frac{\\text{Number of word $w$ in document $d$}}{\\text{Total number of words in document $d$}}$$\n\n**Inverse document frequency (IDF)**  \nThe inverse document frequency is to penalize words that are too common across all documents. For example, auxiliary verbs like 'is' are weighed less as the result. In return, this gives rise to rarer words that possibly carry more meaning and importance. \n\n$$IDF = \\log\\left(\\frac{\\text{Total number of documents}}{\\text{Number of documents containing word $w$}}\\right)$$\n\n**Combining both TF and IDF**  \nTo have our TF-IDF representation, we multiply both terms to have the following formula:\n\n$$TF\\text{-}IDF = TF \\times IDF$$\n\nNow, let's revisit our example with TF-IDF in Python. Luckily, the `scikit-learn` package [@scikit-learn] also has a function for TF-IDF called `TfidfVectorizer`. As shown in the first row in @tbl-tfidf, the TF-IDF representation for 'the' is smaller than 'cat' even though they both have the same BoW representations in @tbl-sklearn. This is the result of the compensation from IDF as 'the' is too common among existing documents. \n\n::: {#tbl-tfidf .cell tbl-cap='TF-IDF results from TfidfVectorizer' execution_count=2}\n``` {.python .cell-code}\nimport pandas as pd\nfrom sklearn.feature_extraction.text import TfidfVectorizer\n\n# Using the same example\ndocuments = [\n    'The cat and the cat hate each other.',\n    'The dog is the bird.',\n    'No, the bird and cat hate other dog.'\n]\n\ntfidf = TfidfVectorizer()\nX = tfidf.fit_transform(documents)\ntfidf_df = pd.DataFrame(\n    X.toarray(), columns=tfidf.get_feature_names_out().tolist(), index=documents\n)\ntfidf_df\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>and</th>\n      <th>bird</th>\n      <th>cat</th>\n      <th>dog</th>\n      <th>each</th>\n      <th>hate</th>\n      <th>is</th>\n      <th>no</th>\n      <th>other</th>\n      <th>the</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>The cat and the cat hate each other.</th>\n      <td>0.299594</td>\n      <td>0.000000</td>\n      <td>0.599187</td>\n      <td>0.000000</td>\n      <td>0.39393</td>\n      <td>0.299594</td>\n      <td>0.000000</td>\n      <td>0.000000</td>\n      <td>0.299594</td>\n      <td>0.465322</td>\n    </tr>\n    <tr>\n      <th>The dog is the bird.</th>\n      <td>0.000000</td>\n      <td>0.403525</td>\n      <td>0.000000</td>\n      <td>0.403525</td>\n      <td>0.00000</td>\n      <td>0.000000</td>\n      <td>0.530587</td>\n      <td>0.000000</td>\n      <td>0.000000</td>\n      <td>0.626747</td>\n    </tr>\n    <tr>\n      <th>No, the bird and cat hate other dog.</th>\n      <td>0.346438</td>\n      <td>0.346438</td>\n      <td>0.346438</td>\n      <td>0.346438</td>\n      <td>0.00000</td>\n      <td>0.346438</td>\n      <td>0.000000</td>\n      <td>0.455524</td>\n      <td>0.346438</td>\n      <td>0.269040</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nTF-IDF is a step-up from BoW as it recognizes what makes a word important in a document. However, similar to BoW, it also disregards the order and context of words. Thus, we need some alternatives that can compute an even better representation for words.\n\n## Word Embeddings\n\nThis is where word embeddings come into play. Contrary to traditional methods, word embeddings encode words in vector forms (from Linear Algebra!). Through vector representations, they can encapsulate the relationships between words by showing their similarity numerically. Mathematically, the similarity in words is measured by how close the embeddings are in the vector space. @fig-embedding shows an example of visualizing word embeddings in a 2-dimensional space. As you can see, words that are similar in meaning or context are clustered together. This is the art of word embeddings!\n\n![Visualization of word embeddings (Source: Ruben Winastwan)](wordembedding.png){#fig-embedding}\n\n### Word2Vec\nOne common tool to obtain word embeddings is Word2Vec [@mikolov2013efficient]. It computes the embeddings by leveraging the architecture of two-layer neural networks. There are two approaches that Word2Vec uses to obtain these embeddings.\n\n**Continuous BoW (CBoW)**  \n\nCBoW is a prediction algorithm where the neural network aims to predict a target word based on the existing context in a document. Simply put, this is analogous to filling in the blank in a sentence. \n\nConsider the sentence *\"My cute puppy is barking\"*. The model will iterate over this sentence and remove one word from each iteration. For example, as shown in @fig-cbow, the model omits the word *'puppy'* from the sentence and trains the neural network to guess the word *'puppy'* from the remaining sentence.\n\n::: {style=\"text-align:center;\"}\n![Illustration of CBoW algorithm](cbow.jpeg){#fig-cbow}\n:::\n\n**Skipgram**\n\nSkipgram is the complete opposite of CBoW. Instead of predicting the missing word from a given context, skipgram predicts the surrounding context from a given word. Using the same example, as shown in @fig-skipgram, the model will try to guess the surrounding words to the word *'puppy'*.\n\n::: {style=\"text-align:center;\"}\n![Illustration of Skipgram algorithm](skipgram.jpeg){#fig-skipgram}\n:::\n\nAfter multiple iterations in the training process, Word2Vec will use the learned weights in the neural network from either of the approaches to construct the word embeddings for each word. \n\nApplying Word2Vec in Python is made possible with the package `Gensim` [@rehurek2011gensim]. As seen in @lst-gensim, `Gensim`'s `Word2Vec` takes in a list of lists to generate the word embeddings. Note that the `sg` argument in the function lets you choose between CBoW and skipgram, where 0 and 1 corresponds to CBoW and skipgram respectively. The argument `min_count` tells the model to ignore words that have a fewer count than this minimum. After training `Word2Vec` on our sample text, we can take a quick look into how word embeddings look like for the word 'technology' in @lst-gensim. \n\n::: {#79c944a2 .cell execution_count=3}\n``` {#lst-gensim .python .cell-code lst-cap=\"This code demonstrates extracting word embedding from the word 'technology'\"}\nimport pandas as pd\nfrom gensim.models import Word2Vec\n# Generated by ChatGPT\nsample_text = [\n    \"The advancement of technology has transformed the way we communicate and interact with the world.\",\n    \"Artificial intelligence is increasingly being used in healthcare, education, and other industries to enhance efficiency.\",\n    \"People often gather in coffee shops to discuss ideas, share stories, and enjoy a sense of community.\",\n    \"Self-driving cars and smart home devices are examples of how technology is becoming a part of our everyday lives.\",\n    \"Art galleries and cultural festivals are popular spots for people to explore creativity and connect with others.\",\n    \"The integration of AI in the workplace has sparked debates about its impact on jobs and productivity.\",\n    \"Reading books and attending literary events remain cherished activities in the digital age.\",\n    \"Many cities are blending technology with traditional practices to create unique and thriving environments.\",\n    \"The use of virtual reality in gaming and training has opened new possibilities for immersive experiences.\",\n    \"Social media platforms have changed the way we form relationships and share information globally.\"\n]\n# This generates a list of lists\nsample_sentences = [sent.split() for sent in sample_text]\n\nw2v = Word2Vec(sample_sentences, min_count = 1, sg = 1)\nprint(w2v.wv['technology'])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[ 8.1346482e-03 -4.3696621e-03 -1.0951435e-03  1.0827162e-03\n -1.6076697e-04  1.0314664e-03  6.1621480e-03  1.0513653e-04\n -3.3200562e-03 -1.6226495e-03  5.8745840e-03  1.3788766e-03\n -6.8573974e-04  9.4051417e-03 -4.8837205e-03 -9.1557507e-04\n  9.1908397e-03  6.7008133e-03  1.4975395e-03 -9.0892995e-03\n  1.2369623e-03 -2.2766890e-03  9.4154952e-03  1.1043868e-03\n  1.5170779e-03  2.3703994e-03 -1.9285623e-03 -4.9641491e-03\n  1.0452364e-04 -2.0255600e-03  6.6222828e-03  8.9008864e-03\n -5.9560389e-04  2.8281522e-03 -6.1490987e-03  1.7546985e-03\n -6.8589435e-03 -8.6309118e-03 -5.9207552e-03 -9.0170074e-03\n  7.2529181e-03 -5.8431132e-03  8.1692915e-03 -7.1991798e-03\n  3.4998127e-03  9.6219182e-03 -7.8216838e-03 -9.9756923e-03\n -4.2250603e-03 -2.6117193e-03 -2.6378274e-04 -8.8602239e-03\n -8.5995235e-03  2.7603817e-03 -8.2284901e-03 -9.0225162e-03\n -2.3512202e-03 -8.6695738e-03 -7.1790209e-03 -8.3399629e-03\n -2.7452479e-04 -4.5728176e-03  6.6562551e-03  1.5371529e-03\n -3.3772779e-03  6.1904443e-03 -5.9688864e-03 -4.5542065e-03\n -7.3182448e-03 -4.1977805e-03 -1.7964148e-03  6.5716160e-03\n -2.7138642e-03  4.9592862e-03  6.9808913e-03 -7.4309111e-03\n  4.5860992e-03  6.1515258e-03 -2.9300000e-03  6.6001783e-03\n  6.0655614e-03 -6.4467844e-03 -6.8669897e-03  2.5851957e-03\n -1.7241427e-03 -6.1018453e-03  9.5864786e-03 -5.1106275e-03\n -6.4399107e-03 -4.0861694e-05 -2.5958647e-03  5.0307182e-04\n -3.4884498e-03 -3.8938067e-04 -6.8298483e-04  8.8520558e-04\n  8.1980843e-03 -5.7321084e-03 -1.6760164e-03  5.5565243e-03]\n```\n:::\n:::\n\n\nAs it turns out, the word embedding for 'technology' is a high-dimensional vector. However, the values are much more ambiguous than the previous representations we have learned earlier. Let's try to translate these embeddings into more comprehensible results. \n\nAs mentioned before, word embeddings are powerful at capturing similarities in words. We are putting this to test in @lst-similarity, where we ask `Word2Vec` what the most similar word to 'technology' is. The result shows that 'advancement' is the closest word choice. This is a reasonable pick since we often use the phrase 'technological advancement' when describing new technological milestones.\n\n::: {#1cb750c7 .cell execution_count=4}\n``` {#lst-similarity .python .cell-code lst-cap=\"This code shows what Word2Vec thinks the most similar word to 'technology' is.\"}\nprint(w2v.wv.most_similar('technology')[0])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n('advancement', 0.3503554165363312)\n```\n:::\n:::\n\n\nWord2Vec is a big improvement from traditional methods. Nevertheless, it still has flaws such as failing to recognize unknown words. Since Word2Vec is a pre-trained model, its linguistic knowledge mainly bases on the data corpus it was trained on. Unfortunately, language changes over time as new words continue to pop up in dictionaries every year. Thus, it is only a matter of time that Word2Vec will become outdated. Another limitation of Word2Vec is that it struggles to differentiate between words with multiple meanings. Since Word2Vec generates a word embedding for each unique word, it fails to acknowledge that a word can carry separate meanings. This can be problematic especially when words can have exact opposite meanings given different contexts.\n\n## Contextualized Embeddings\n\nSimilar to word embeddings, contextualized embeddings also encode texts into high-dimensional vectors. They build on top of the existing framework of word embeddings by conditioning each word on its context. When obtaining the contextualized embeddings of a word, it includes neighbouring words in the calculation. As such, same words that appear in different contexts will have different embeddings. This provides a solution to the limitations of word embeddings as it learns the word based on the context surrounding it.  \n\nWhile there are several architectures, such as ELMo and GPT-2, that are trained on obtaining contextualized embeddings, we will be focusing on learning the BERT model in this section. \n\n![Bert from Sesame Street. Coincidentally, the popular contextualized embeddings are conveniently named as Sesame Street characters (Source: Sesame Street)](bertsesame.jpeg)\n\n\n### BERT\n\nBERT [@devlin2019bertpretrainingdeepbidirectional], which stands for Bidirectional encoder representations from transformers, is a transformer-based encoder model developed in 2018 by researchers at Google [@Devlin_Chang_2018]. \n\nIt is bidirectional in the sense that it captures the both left and right contexts of a given word. For example, consider the sentence *\"You exist in the context of all in which you live\"* and the target word *\"context\"*. The bidirectional nature of BERT ensures that both the left context, *\"You exist in the\"*, and the right context, *\"of all in which you live\"*, are taken into consideration. \n\nTransformer [@vaswani2017attention], in this context, is a deep-learning architecture that revolutionalizes the field of NLP through its emphasis on contextualized representations. Its usage ranges from language translations to text generations. As shown in @fig-transformer, transformer is powered by two separate mechanisms: an encoder system that reads an input text and produces a corresponding vector representation, and a decoder system that receives the vector representation and output sentences that are useful in tasks like text generation [@Hoque_2024]. Despite BERT being a transformer-based model, it differs from a typical transformer as BERT only leverages the encoder mechanism of transformers since its goal is to create contextualized embeddings.\n\n![An oversimplified visualization of encoder-decoder mechanism of a transformer. (Source: KiKaBeN)](transformer.png){#fig-transformer}\n\nTo implement BERT in Python, we enlist the help of the Hugging Face library [@wolf2020huggingfacestransformersstateoftheartnatural]. This implementation requires the packages `transformers` and `torch`. To install both packages, use the commands `pip install transformers` and `pip install torch` respectively.\n\nBefore producing BERT embeddings, we have to tokenize the input text with `BertTokenizer` in @lst-token. Tokenization is a process where we break down a text into smaller chunks, similar to extracting individual words from sentences. However, tokenization does not necessarily return a list of words as it aims to deconstruct texts in a way that facilitates the embedding computations. From the result of @lst-token, we see that `BertTokenizer` generates 33 tokens from the input text and the character or word that each token represents.\n\n::: {#bd0f7afc .cell execution_count=5}\n``` {#lst-token .python .cell-code lst-cap=\"This code shows how BERT tokenization works.\"}\nfrom transformers import BertTokenizer, BertModel\nimport torch\n\n# Load pre-trained BERT tokenizer\ntokenizer = BertTokenizer.from_pretrained('bert-base-uncased')\n\n# Generated by ChatGPT\ntext = \"Artificial intelligence is revolutionizing industries, making processes faster and more efficient. Despite its rapid advancements, human creativity and empathy remain irreplaceable.\"\n\n# Tokenize the input text\ninputs = tokenizer(text, return_tensors='pt', truncation=True, padding=True)\ntokens = inputs['input_ids'][0]\n\n# Tokenization results\nprint(f'Number of tokens generated: {tokens.shape[0]}')\nprint(tokenizer.convert_ids_to_tokens(tokens.numpy()))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNumber of tokens generated: 33\n['[CLS]', 'artificial', 'intelligence', 'is', 'revolution', '##izing', 'industries', ',', 'making', 'processes', 'faster', 'and', 'more', 'efficient', '.', 'despite', 'its', 'rapid', 'advancement', '##s', ',', 'human', 'creativity', 'and', 'empathy', 'remain', 'ir', '##re', '##pl', '##ace', '##able', '.', '[SEP]']\n```\n:::\n:::\n\n\nIn @lst-bert, we input the tokens into the pre-trained `BertModel` and reutrn the BERT embedding for the token 'artificial'. The resulting BERT embedding for 'artificial' is a 768-dimensional vector.\n\n::: {#c232dc89 .cell execution_count=6}\n``` {#lst-bert .python .cell-code lst-cap=\"This code shows how we compute BERT embeddings.\"}\n# Load pre-trained BERT model\nmodel = BertModel.from_pretrained('bert-base-uncased')\n\n# Get the embeddings from the BERT model\nwith torch.no_grad():\n    outputs = model(**inputs)\n\n# Extract embeddings\ntoken_embeddings = outputs.last_hidden_state[0]\n\n# Token embeddings shape: (number of tokens in input, embedding dimension)\nprint(f\"Token: {tokenizer.convert_ids_to_tokens(tokens.numpy())[1]}\")\nprint(f\"Embedding shape: {token_embeddings[1].shape}\")\nprint(f\"First 10 values in the embedding: {token_embeddings[1][:10]}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nToken: artificial\nEmbedding shape: torch.Size([768])\nFirst 10 values in the embedding: tensor([ 0.1357,  0.3550, -0.1805,  0.1837,  0.5278,  0.0016,  0.1048,  0.4054,\n         0.2871, -0.8610])\n```\n:::\n:::\n\n\n## References\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}